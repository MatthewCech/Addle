Color palette

maybe add the feature where the viewport can be temporarily locked relative
to the absolute global screen position -- so toolbars and dock widgets can
be added arbitrarily without disrupting the viewport

misc:

when porting to Windows, make sure to specify cmake version 3.4 and add the
property WINDOWS_EXPORT_ALL_SYMBOLS to the shared object modules.

style: enum capitalization, BaseXXX or XXXBase?, initialize_p

Zoom slider: notches, and snapping to presets.

Zoom presets will need some serious work before too long.

Lifetime of views and presenters, of all objects really

cut icon
redo icon looks like it's disabled

clean up dynamic casting (and virtual inheritance) where possible -- see also 
IFormatModel

Make a generalized fallback format driver based on Qt rather than a bunch of
individual ones (dynamic negotiation based on QImageReader::supportedMimeTypes()
for example)

General-purpose assert function that translates into a thrown IAddleException
which returns true for isLogicError() -- save some unneeded micro exception
classes 

error-wrap, but also combine some functionality between the 
unhandledexceptionrouter and the debug message handler

Icons need some kind of configurable interface

style: namespaces!!! (we'll support plugins eventually, might as well be courteous)

trim down readme. it doesn't need to be so rambly

Use QPainterPath subtraction to avoid overpainting in brush operations --
a brush operation should probably be separate from (derived from?) other kinds
of raster operations but also maintain some common interfacing and
functionality.

Tool options bars will need some more work.

The whole UI needs work, lots and lots of work

cut down on #include networks in interface classes with more forward-
declarations to reduce compile times at least a little

Is there some way to make qobject_interface_cast work via qobject_cast instead 
of dynamic_cast ? Maybe interfaces implemented as qobject can be required to 
expose a asQObject() method? Is it actually all that bad as is?

Pass presenters with shared or weak pointers? const references to shared/weak 
pointers (might be easier on the include network)? At least make init function
and constructor signatures consistent
Okay but no really what am I doing with this situation because I've got a
hodgepodge of pointers and references and smart pointers scattered amongst all
supporting and related classes.

reusable (shared?) cache of viewport info for view items that draw themselves
with respect to the viewport. Maybe with a QWidget pointer to the ViewPort as a 
handle to check against, during the paint call.

property decorations should be more metadata-ish and less interface-ish
The thing about property decorations is that they're generally static, and often
automatically generated string keys for reference against a translation table.
But the trouble is not always.

InitHelper:

- Do less/nothing in release builds (optimization, low priority)
- For init functions, make a scope-limited object whose constructor calls
  initializeBegin() and whose destructor callse initializeEnd(), would simplify
  some syntax

Widgets gui focus issues

style: Models should have Model in their names.

Raster Surface lazy clear
+ async safety

I think I'd prefer the semantics if the tool mouse helper were constructed on 
mouse down and destroyed on mouse release (or on abort), and tool logic
involving creation and release of resources were tied to those events.

Async brush painting -- perform all (non-purely-presentational) drawing
operations on a different thread? BEEF UP ASYNC TASK STUFF

Is IService necessary? Services don't really seem to need a common interface,
either for ServiceLocator or consuming code, and thanks to IFactory::delete_(),
ServiceLocator can store services as void* and still access their destructors.
Might also be better semantics, to distinguish between gettable singleton
interfaces, and the more specific concept of a service.

Also, tidy up the gettable_by_id trait vs DECL_PERSISTENT_OBJECT_TYPE thing 

Maybe move stuff into a 'interfaces/meta' folder, or even distinguish between 
'common' and perhaps 'framework'. (Probably would only be useful if I were going
to make another SOLID application in Qt... so it can probably wait for a long
while.)

Don't allow ServiceLocator to publicly make objects that are meant to be
persistent / singletons. befriend ServiceLocator to IFactory and make IFactory 
methods protected.