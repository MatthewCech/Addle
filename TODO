Color palette

maybe add the feature where the viewport can be temporarily locked relative
to the absolute global screen position -- so toolbars and dock widgets can
be added arbitrarily without disrupting the viewport

misc:

style: enum capitalization, BaseXXX or XXXBase?, initialize_p

Zoom slider: notches, and snapping to presets.

Zoom presets will need some serious work before too long.

Lifetime of views and presenters, of all objects really

cut icon
redo icon looks like it's disabled
put dark outlines on the icons so they look good on light backgrounds

clean up dynamic casting (and virtual inheritance) where possible -- see also 
IFormatModel

Make a generalized fallback format driver based on Qt rather than a bunch of
individual ones (dynamic negotiation based on QImageReader::supportedMimeTypes()
for example)

General-purpose assert function that translates into a thrown IAddleException
which returns true for isLogicError() -- save some unneeded micro exception
classes 

error-wrap, but also combine some functionality between the 
unhandledexceptionrouter and the debug message handler

style: namespaces!!! (we'll support plugins eventually, might as well be courteous)

Tool options bars will need some more work.

The whole UI needs work, lots and lots of work

cut down on #include networks in interface classes with more forward-
declarations to reduce compile times at least a little

Is there some way to make qobject_interface_cast work via qobject_cast instead 
of dynamic_cast ? Maybe interfaces implemented as qobject can be required to 
expose a asQObject() method? Is it actually all that bad as is?

Pass presenters with shared or weak pointers? const references to shared/weak 
pointers (might be easier on the include network)? At least make init function
and constructor signatures consistent
Okay but no really what am I doing with this situation because I've got a
hodgepodge of pointers and references and smart pointers scattered amongst all
supporting and related classes.

reusable (shared?) cache of viewport info for view items that draw themselves
with respect to the viewport. Maybe with a QWidget pointer to the ViewPort as a 
handle to check against, during the paint call.
^ Giving graphics framework-based view access to their viewports probably does
not represent enough of a performance hit to warrant much action here.

InitHelper:

- Where does it get off having no default constructor. This shouldn't be a
  template class, it is *not* that important as a debugging or diagnostic tool.
- Do less/nothing in release builds (optimization, low priority)
- For init functions, make a scope-limited object whose constructor calls
  initializeBegin() and whose destructor callse initializeEnd(), would simplify
  some syntax

Widgets gui focus issues

style: Models should have Model in their names. ?

Raster Surface lazy clear
+ async safety

I think I'd prefer the semantics if the tool mouse helper were constructed on 
mouse down and destroyed on mouse release (or on abort), and tool logic
involving creation and release of resources were tied to those events.

Async brush painting -- perform all (non-purely-presentational) drawing
operations on a different thread? BEEF UP ASYNC TASK STUFF

Is IService necessary? Services don't really seem to need a common interface,
either for ServiceLocator or consuming code, and thanks to IFactory::delete_(),
ServiceLocator can store services as void* and still access their destructors.
Might also be better semantics, to distinguish between gettable singleton
interfaces, and the more specific concept of a service.

Also, tidy up the gettable_by_id trait vs DECL_PERSISTENT_OBJECT_TYPE thing 

Maybe move stuff into a 'interfaces/meta' folder, or even distinguish between 
'common' and perhaps 'framework'. (Probably would only be useful if I were going
to make another SOLID application in Qt... so it can probably wait for a long
while.)

Don't allow ServiceLocator to publicly make objects that are meant to be
persistent / singletons. befriend ServiceLocator to IFactory and make IFactory 
methods protected.

AsyncTask needs to be verified for correctness with unit tests

generic data structure representing a collection of rectangles indexed by
position with btrees
- Quickly test whether a given rectangle intersects with one or more rectangles
  in the collection
- Quickly test whether a given rectangle is covered by one or more rectangles
  in the collection
- Get a list of the rectangles that intersect with a given rectangle (e.g., to
  convert it into a conservative QPainterPath for use as a clip region)

RenderData can use this to hold masks made of rectangle segments, and render 
steps can cheaply minimize or skip drawing logic when appropriate

BasicBrush can use this to redraw itself by section more quickly

https://stackoverflow.com/questions/3374743/c-const-getter-method-with-lazy-initialization
(tl;dr) we can make a const getter with lazy init. This is generally regarded as
not violating constness, but I don't want to make every lazy-initialized member
`mutable`. A LazyConstValue class like `suspension` in the thread will be
desirable

I don't like the one in the thread (the saved-off init function feels off to me),*
so I think have mine expose a mutable a setter that only works once.

(
  Am I sure I don't like this... tbh? Wouldn't the constructor be a more appropriate
  place for initialization code, and the suspension class would automatically handle
  the init check which would be super convenient, plus I wouldn't need to bother with
  runtime assertions on the setter.

  Consider:

  ```
  private:
      const LazySharedPointer<IFoo> _foo;

      // ...

  public:
      QSharedPointer<IFoo> getFoo() const { return _foo; }

      // ...

      c'tor()
          : _foo(std::bind(ServiceLocator::makeShared, this))
      {
      }

  ```

  That honestly feels pretty clean
)

* This does beg the question if I want to refactor PropertyCache.

If I feel like a c'tor's initialization list is getting kind of cumbersome
I can move the it to the implementation file. It'd look right at home next to
the proper init function.

Anyway, tackle that when we're tightening up constness

chuck QImage::offset() into more of the API

make renderstack auto-remove steps as they're deleted

right-clicking in the middle of a tool operation causes it to disengage
haphazardly

okay but *reeeeaaallllyy* do I have to insist on get- property method names,
because *nobody* else does that and it's not even consistent with C# (i.e., the
counterexample I keep thinking of.)

combine the raster bit reader and writer?

All Addle code should be in Addle namespace, and global constants will not have
a sub-namespace 

get format drivers by id 

text.json keys have kebab-case camelCase and snake_case.
they should probably be unified

Format stuff needs basically an overhaul I know, but consider making
FormatId a template class rather than tracking model type at runtime

Maybe make common utilities that formalize core brush engines' parameters (and
states?) into more of an API. Make some kind of "interface" class that marhsals
with the QVariantHash and exposes statically named and typed properties, perhaps
performs some degree of validation logic.

^ combine this with BrushId builder(s) to more conveniently build brush
id's with complex metadata.

It'd be nice to have some kind of generic validator for QVariantHash (and/or 
QDataStream, QJsonDocument), in the vein of an XML Schema validator, with rich
error output and possibly even some conformity enforcement. But unless someone
else has made one (MIT-compatible), I don't think it is worth the considerable
undertaking of making one myself.

Soft brush also has an artifact where part of the feathering is clipped sometimes.

EVENTUALLY: simplify / modularize / optimize path brush engine's anti-aliasing
repair logic.

Raster engine: figure out an easing function that can be adjusted for different
hardnesses

error messaging on PropertyBinding

Make a adapter/interface to fit a presenter onto QListWidget (or QListView --
most of the feature differences are overkill but if we're making an abstraction,
kinda might as well)

# Const-correctness checklist:

- ServiceLocator should be extended to handle getting and making const vs non-
  const types.
- All member functions of interfaces should be declared `const` where
  appropriate. And of course, all implementations should follow.
- Some kind of property wrapper for lazily-initialized values should permit
  those values to be populated from within a const function (see above)
- **qAsConst() must be employed on all range-based for loops over implicitly
  shared collection types to avoid lots and lots of unneeded copying** -- wowie (:

Absolutely only one file for interface traits.

Shared pool of temporary/disposable raster surfaces for various kinds of brush 
previews?

Brush icons of a certain exceeding size should have an additional hint that they
are very big. (maybe a plus sign in the corner?)

maybe change the navigate tool icon to a hand? That's a recognizable tool, and
a decent representation of what the tool does? (of course it doesn't imply zoom
so maybe it's fine as it)

Eventually add a special viewport control similar to what Gwenview has, where 
(when the navigate tool is selected) you can hover over the viewport and in the
corner an abstract "mini-map" appears and can be used to drag the viewport around
the canvas area.