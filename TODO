Color palette

maybe add the feature where the viewport can be temporarily locked relative
to the absolute global screen position -- so toolbars and dock widgets can
be added arbitrarily without disrupting the viewport

misc:

when porting to Windows, make sure to specify cmake version 3.4 and add the
property WINDOWS_EXPORT_ALL_SYMBOLS to the shared object modules.

style: enum capitalization, BaseXXX or XXXBase?, initialize_p

Zoom slider: notches, and snapping to presets.

Zoom presets will need some serious work before too long.

Lifetime of views and presenters, of all objects really

cut icon
redo icon looks like it's disabled

clean up dynamic casting (and virtual inheritance) where possible -- see also 
IFormatModel

Make a generalized fallback format driver based on Qt rather than a bunch of
individual ones (dynamic negotiation based on QImageReader::supportedMimeTypes()
for example)

General-purpose assert function that translates into a thrown IAddleException
which returns true for isLogicError() -- save some unneeded micro exception
classes 

error-wrap, but also combine some functionality between the 
unhandledexceptionrouter and the debug message handler

Icons need some kind of configurable interface

style: namespaces!!! (we'll support plugins eventually, might as well be courteous)

trim down readme. it doesn't need to be so rambly

Use QPainterPath subtraction to avoid overpainting in brush operations --
a brush operation should probably be separate from (derived from?) other kinds
of raster operations but also maintain some common interfacing and
functionality.

Tool options bars will need some more work.

The whole UI needs work, lots and lots of work

cut down on #include networks in interface classes with more forward-
declarations to reduce compile times at least a little

Is there some way to make qobject_interface_cast work via qobject_cast instead 
of dynamic_cast ? Maybe interfaces implemented as qobject can be required to 
expose a asQObject() method? Is it actually all that bad as is?

Pass presenters with shared or weak pointers? const references to shared/weak 
pointers (might be easier on the include network)? At least make init function
and constructor signatures consistent
Okay but no really what am I doing with this situation because I've got a
hodgepodge of pointers and references and smart pointers scattered amongst all
supporting and related classes.

reusable (shared?) cache of viewport info for view items that draw themselves
with respect to the viewport. Maybe with a QWidget pointer to the ViewPort as a 
handle to check against, during the paint call.

property decorations should be more metadata-ish and less interface-ish
The thing about property decorations is that they're generally static, and often
automatically generated string keys for reference against a translation table.
But the trouble is not always.

InitHelper:

- Where does it get off having no default constructor. This shouldn't be a
  template class, it is *not* that important as a debugging or diagnostic tool.
- Do less/nothing in release builds (optimization, low priority)
- For init functions, make a scope-limited object whose constructor calls
  initializeBegin() and whose destructor callse initializeEnd(), would simplify
  some syntax

Widgets gui focus issues

style: Models should have Model in their names.

Raster Surface lazy clear
+ async safety

I think I'd prefer the semantics if the tool mouse helper were constructed on 
mouse down and destroyed on mouse release (or on abort), and tool logic
involving creation and release of resources were tied to those events.

Async brush painting -- perform all (non-purely-presentational) drawing
operations on a different thread? BEEF UP ASYNC TASK STUFF

Is IService necessary? Services don't really seem to need a common interface,
either for ServiceLocator or consuming code, and thanks to IFactory::delete_(),
ServiceLocator can store services as void* and still access their destructors.
Might also be better semantics, to distinguish between gettable singleton
interfaces, and the more specific concept of a service.

Also, tidy up the gettable_by_id trait vs DECL_PERSISTENT_OBJECT_TYPE thing 

Maybe move stuff into a 'interfaces/meta' folder, or even distinguish between 
'common' and perhaps 'framework'. (Probably would only be useful if I were going
to make another SOLID application in Qt... so it can probably wait for a long
while.)

Don't allow ServiceLocator to publicly make objects that are meant to be
persistent / singletons. befriend ServiceLocator to IFactory and make IFactory 
methods protected.

AsyncTask needs to be verified for correctness with unit tests

generic data structure representing a collection of rectangles indexed by
position with btrees
- Quickly test whether a given rectangle intersects with one or more rectangles
  in the collection
- Quickly test whether a given rectangle is covered by one or more rectangles
  in the collection
- Get a list of the rectangles that intersect with a given rectangle (e.g., to
  convert it into a conservative QPainterPath for use as a clip region)

RenderData can use this to hold masks made of rectangle segments, and render 
steps can cheaply minimize or skip drawing logic when appropriate

BasicBrush can use this to redraw itself by section more quickly

https://stackoverflow.com/questions/3374743/c-const-getter-method-with-lazy-initialization
(tl;dr) we can make a const getter with lazy init. This is generally regarded as
not violating constness, but I don't want to make every lazy-initialized member
`mutable`. A LazyConstValue class like `suspension` in the thread will be
desirable

I don't like the one in the thread (the saved-off init function feels off to me),*
so I think have mine expose a mutable a setter that only works once.

(
  Am I sure I don't like this... tbh? Wouldn't the constructor be a more appropriate
  place for initialization code, and the suspension class would automatically handle
  the init check which would be super convenient, plus I wouldn't need to bother with
  runtime assertions on the setter.

  Consider:

  ```
  private:
      const LazySharedPointer<IFoo> _foo;

      // ...

  public:
      QSharedPointer<IFoo> getFoo() const { return _foo; }

      // ...

      c'tor()
          : _foo(std::bind(ServiceLocator::makeShared, this))
      {
      }

  ```

  That honestly feels pretty clean
)

* This does beg the question if I want to refactor PropertyCache.

If I feel like a c'tor's initialization list is getting kind of cumbersome
I can move the it to the implementation file. It'd look right at home next to
the proper init function.

Anyway, tackle that when we're tightening up constness

Despite it all, BasicBrush still has anit-aliasing artifacts at the endpoints of
moveTo paints. fix this
