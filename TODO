Color palette

maybe add the feature where the viewport can be temporarily locked relative
to the absolute global screen position -- so toolbars and dock widgets can
be added arbitrarily without disrupting the viewport

misc:

when porting to Windows, make sure to specify cmake version 3.4 and add the
property WINDOWS_EXPORT_ALL_SYMBOLS to the shared object modules.

style: enum capitalization, BaseXXX or XXXBase?, initialize_p

Zoom slider: notches, and snapping to presets.

Zoom presets will need some serious work before too long.

Lifetime of views and presenters

cut icon
redo icon looks like it's disabled

clean up dynamic casting (and virtual inheritance) where possible -- see also 
IFormatModel

Make a generalized fallback format driver based on Qt rather than a bunch of
individual ones (dynamic negotiation based on QImageReader::supportedMimeTypes()
for example)

General-purpose assert function that translates into a thrown IAddleException
which returns true for isLogicError() -- save some unneeded micro exception
classes 

error-wrap, but also combine some functionality between the 
unhandledexceptionrouter and the debug message handler

Icons need some kind of configurable interface

style: namespaces???

trim down readme. it doesn't need to be so rambly

Use QPainterPath subtraction to avoid overpainting in brush operations --
a brush operation should probably be separate from (derived from?) other kinds
of raster operations but also maintain some common interfacing and
functionality.

Tool options bars will need some more work.

The whole UI needs work, lots and lots of work

cut down on #include networks in interface classes with more forward-
declarations to reduce compile times at least a little

Is there some way to make qobject_interface_cast work via qobject_cast instead 
of dynamic_cast ? Maybe interfaces implemented as qobject can be required to 
expose a asQObject() method? Is it actually all that bad as is?

Look back into ServiceLocator and see if we can't leverage the static linker
more with it. The performance is probably fine as-is, but it'd very much be to
our advantage to get linker errors instead of runtime ones for a bad
configuration. And overall it'd be more C++-esque.
Potential complications might involve unit tests and dynamically loaded code
(i.e., plugins), but I think we can adapt.

Pass presenters with shared or weak pointers? const references to shared/weak 
pointers (might be easier on the include network)? At least make init function
and constructor signatures consistent
Okay but no really what am I doing with this situation because I've got a
hodgepodge of pointers and references and smart pointers scattered amongst all
supporting and related classes.

reusable (shared?) cache of viewport info for view items that draw themselves
with respect to the viewport. Maybe with a QWidget pointer to the ViewPort as a 
handle to check against, during the paint call.

property decorations should be more metadata-ish and less interface-ish
The thing about property decorations is that they're generally static, and often
automatically generated string keys for reference against a translation table.
But the trouble is not always.

InitHelper:

- Do less/nothing in release builds (optimization, low priority)
- For init functions, make a scope-limited object whose constructor calls
  initializeBegin() and whose destructor callse initializeEnd(), would simplify
  some syntax

see if PropertyCache can't be made more flexible with std::function and
std::bind

Widgets gui focus issues